{"version":3,"sources":["backend.ts"],"names":["tensorTypeToTypedArray","type","Float32Array","Int8Array","Int16Array","Int32Array","Float64Array","BigInt64Array","Error","OnnxruntimeSessionHandler","constructor","path","binding","inputNames","outputNames","loadModel","options","results","key","Promise","resolve","e","dispose","startProfiling","endProfiling","run","feeds","fetches","reject","fetch","push","input","encodeFeedsType","output","decodeReturnType","returnValue","Object","hasOwnProperty","call","data","Array","isArray","Buffer","from","buffer","toString","dims","tensorData","typedArray","byteOffset","length","BYTES_PER_ELEMENT","Tensor","OnnxruntimeBackend","init","createSessionHandler","pathOrBuffer","handler","onnxruntimeBackend"],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport {\n  Backend,\n  InferenceSession,\n  SessionHandler,\n  Tensor,\n} from 'onnxruntime-common';\nimport { binding, Binding } from './binding';\nimport { Buffer } from 'buffer';\n\ntype SupportedTypedArray = Exclude<Tensor.DataType, string[]>;\n\nconst tensorTypeToTypedArray = (\n  type: Tensor.Type\n):\n  | Float32ArrayConstructor\n  | Int8ArrayConstructor\n  | Int16ArrayConstructor\n  | Int32ArrayConstructor\n  | BigInt64ArrayConstructor\n  | Float64ArrayConstructor => {\n  switch (type) {\n    case 'float32':\n      return Float32Array;\n    case 'int8':\n      return Int8Array;\n    case 'int16':\n      return Int16Array;\n    case 'int32':\n      return Int32Array;\n    case 'bool':\n      return Int8Array;\n    case 'float64':\n      return Float64Array;\n    case 'int64':\n      /* global BigInt64Array */\n      /* eslint no-undef: [\"error\", { \"typeof\": true }] */\n      return BigInt64Array;\n    default:\n      throw new Error(`unsupported type: ${type}`);\n  }\n};\n\nclass OnnxruntimeSessionHandler implements SessionHandler {\n  #inferenceSession: Binding.InferenceSession;\n  #key: string;\n\n  inputNames: string[];\n  outputNames: string[];\n\n  constructor(path: string) {\n    this.#inferenceSession = binding;\n    this.#key = path;\n    this.inputNames = [];\n    this.outputNames = [];\n  }\n\n  async loadModel(options: InferenceSession.SessionOptions): Promise<void> {\n    try {\n      // load a model\n      const results: Binding.ModelLoadInfoType = await this.#inferenceSession.loadModel(\n        this.#key,\n        options\n      );\n      // resolve promise if onnxruntime session is successfully created\n      if (results.key !== this.#key) {\n        throw new Error('Session key is invalid');\n      }\n\n      this.inputNames = results.inputNames;\n      this.outputNames = results.outputNames;\n      return Promise.resolve();\n    } catch (e) {\n      throw new Error(\"Can't load a model\");\n    }\n  }\n\n  async dispose(): Promise<void> {\n    return Promise.resolve();\n  }\n\n  startProfiling(): void {\n    // TODO: implement profiling\n  }\n  endProfiling(): void {\n    // TODO: implement profiling\n  }\n\n  async run(\n    feeds: SessionHandler.FeedsType,\n    fetches: SessionHandler.FetchesType,\n    options: InferenceSession.RunOptions\n  ): Promise<SessionHandler.ReturnType> {\n    return new Promise(async (resolve, reject) => {\n      try {\n        // Java API doesn't support preallocated output names and allows only string array as parameter.\n        const outputNames: Binding.FetchesType = [];\n        for (const fetch in fetches) {\n          outputNames.push(fetch);\n        }\n        const input = this.encodeFeedsType(feeds);\n        const results: Binding.ReturnType = await this.#inferenceSession.run(\n          this.#key,\n          input,\n          outputNames,\n          options\n        );\n        const output = this.decodeReturnType(results);\n        resolve(output);\n      } catch (e) {\n        reject(e);\n      }\n    });\n  }\n\n  encodeFeedsType(feeds: SessionHandler.FeedsType): Binding.FeedsType {\n    const returnValue: { [name: string]: Binding.EncodedTensorType } = {};\n    for (const key in feeds) {\n      if (Object.hasOwnProperty.call(feeds, key)) {\n        let data: string | string[];\n\n        if (Array.isArray(feeds[key].data)) {\n          data = feeds[key].data as string[];\n        } else {\n          // Base64-encode tensor data\n          data = Buffer.from(\n            (feeds[key].data as SupportedTypedArray).buffer\n          ).toString('base64');\n        }\n\n        returnValue[key] = {\n          dims: feeds[key].dims,\n          type: feeds[key].type,\n          data,\n        };\n      }\n    }\n    return returnValue;\n  }\n\n  decodeReturnType(results: Binding.ReturnType): SessionHandler.ReturnType {\n    const returnValue: SessionHandler.ReturnType = {};\n\n    for (const key in results) {\n      if (Object.hasOwnProperty.call(results, key)) {\n        let tensorData: Tensor.DataType;\n        if (Array.isArray(results[key].data)) {\n          tensorData = results[key].data as string[];\n        } else {\n          const buffer: Buffer = Buffer.from(\n            results[key].data as string,\n            'base64'\n          );\n          const typedArray = tensorTypeToTypedArray(\n            results[key].type as Tensor.Type\n          );\n          tensorData = new typedArray(\n            buffer.buffer,\n            buffer.byteOffset,\n            buffer.length / typedArray.BYTES_PER_ELEMENT\n          );\n        }\n\n        returnValue[key] = new Tensor(\n          results[key].type as Tensor.Type,\n          tensorData,\n          results[key].dims\n        );\n      }\n    }\n\n    return returnValue;\n  }\n}\n\nclass OnnxruntimeBackend implements Backend {\n  async init(): Promise<void> {\n    return Promise.resolve();\n  }\n\n  async createSessionHandler(\n    pathOrBuffer: string | Uint8Array,\n    options?: InferenceSession.SessionOptions\n  ): Promise<SessionHandler> {\n    return new Promise(async (resolve, reject) => {\n      try {\n        if (typeof pathOrBuffer !== 'string') {\n          throw new Error('Uint8Array is not supported');\n        }\n        const handler = new OnnxruntimeSessionHandler(pathOrBuffer);\n        await handler.loadModel(options || {});\n        resolve(handler);\n      } catch (e) {\n        reject(e);\n      }\n    });\n  }\n}\n\nexport const onnxruntimeBackend = new OnnxruntimeBackend();\n"]}